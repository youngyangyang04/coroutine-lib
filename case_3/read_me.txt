案例3 多线程协程模型 在服务器下的应用 一个简单的echo服务器
io_scheduler继承于之前的scheduler类
overwrite了idle和tickle方法 新增了epoll的部分

因为之前每个线程任务只会在一个线程执行到结束，不会中途yield并重新增加回队列
而此次每个协程如果遇到未就绪的fd，需要重新加入任务队列等待epoll发送就绪信号继续执行
所以之前的内容有些许变化，增加了协程的mutex，确保一个协程同一时间只在一个线程上运行 (run函数resume协程时需要先获得协程锁)

协程搭配IO任务最好的地方在于  每个fd都只对应一个自己的协程用来处理fd上的任务 而无需用状态机来记录fd现在运行到那一步了
当这个协程遇到阻塞时 他就会yield 并将执行的状态就保存在协程中（一个携程可以看作一个函数和他所有的运行上下文）
并修改阻塞他的任务到epoll的监听集合 当这个事件再次可用时 直接resume 协程继续顺序执行

想要扩展成http服务器只需要修改doCommonProcess这个流程即可

因为增加了读写锁 我们需要c++的shared_lock来实现

compile using
g++ -std=c++17 *.cpp -o test.a 

测试方法 打开另一个虚拟机终端
telnet 127.0.0.1 8080（改为服务器运行的ip地址）  按照echo server 使用即可 